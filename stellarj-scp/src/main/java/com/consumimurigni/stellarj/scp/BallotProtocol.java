package com.consumimurigni.stellarj.scp;


import java.time.Duration;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Predicate;

import javax.annotation.Nullable;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.consumimurigni.stellarj.scp.SCP.EnvelopeState;
import com.consumimurigni.stellarj.scp.SCPDriver.ValidationLevel;
import com.consuminurigni.stellarj.common.Assert;
import com.consuminurigni.stellarj.scp.xdr.SCPBallot;
import com.consuminurigni.stellarj.scp.xdr.SCPEnvelope;
import com.consuminurigni.stellarj.scp.xdr.SCPStatement;
import com.consuminurigni.stellarj.scp.xdr.SCPStatementType;
import com.consuminurigni.stellarj.scp.xdr.SCPStatement.SCPStatementPledges;
import com.consuminurigni.stellarj.scp.xdr.SCPStatement.SCPStatementPledges.SCPStatementConfirm;
import com.consuminurigni.stellarj.scp.xdr.SCPStatement.SCPStatementPledges.SCPStatementExternalize;
import com.consuminurigni.stellarj.scp.xdr.SCPStatement.SCPStatementPledges.SCPStatementPrepare;
import com.consuminurigni.stellarj.xdr.Hash;
import com.consuminurigni.stellarj.xdr.NodeID;
import com.consuminurigni.stellarj.xdr.UInt32Interval;
import com.consuminurigni.stellarj.xdr.Uint32;
import com.consuminurigni.stellarj.xdr.Value;

public class BallotProtocol {
	private static final Logger log = LogManager.getLogger();

	static final int MAX_ADVANCE_SLOT_RECURSION = 50;

	// state tracking members
	enum SCPPhase {
		SCP_PHASE_PREPARE, SCP_PHASE_CONFIRM, SCP_PHASE_EXTERNALIZE, SCP_PHASE_NUM
	};

	// human readable names matching SCPPhase
	//public static String[] phaseNames /*[SCP_PHASE_NUM]*/ = {"PREPARE", "FINISH", "EXTERNALIZE"};

	@Nullable
	SCPBallot mCurrentBallot; // b
	SCPBallot mPrepared; // p
	SCPBallot mPreparedPrime; // p'
	SCPBallot mHighBallot; // h
	SCPBallot mCommit; // c
	private Slot mSlot;
	private Boolean mHeardFromQuorum;
	Map<NodeID, SCPEnvelope> mLatestEnvelopes; // M
	SCPPhase mPhase; // Phi

	int mCurrentMessageLevel; // number of messages triggered in one run

	SCPEnvelope mLastEnvelope; // last envelope generated by this node

	SCPEnvelope mLastEnvelopeEmit; // last envelope emitted by this node

	public BallotProtocol(Slot slot) {
		this.mSlot = slot;
		this.mHeardFromQuorum = true;
		this.mPhase = SCPPhase.SCP_PHASE_PREPARE;
		this.mCurrentMessageLevel = 0;
	}

	public EnvelopeState processEnvelope(SCPEnvelope envelope, boolean self)
	{
	    EnvelopeState res = EnvelopeState.INVALID;
	    Assert.assertTrue(envelope.getStatement().getSlotIndex().eq(mSlot.getSlotIndex()));

	    SCPStatement statement = envelope.getStatement();
	    NodeID nodeID = statement.getNodeID();

	    if (!isStatementSane(statement, self))
	    {
	        if (self)
	        {
	            log.error("SCP not sane statement from self, skipping  e: {}", mSlot.getSCP().envToStr(envelope));
	        }

	        return SCP.EnvelopeState.INVALID;
	    }

	    if (!isNewerStatement(nodeID, statement))
	    {
	        if (self)
	        {
	            log.error("SCP stale statement from self, skipping  e: {}", mSlot.getSCP().envToStr(envelope));
	        }
	        else
	        {
	            log.trace("SCP stale statement from self, skipping  i: {}", mSlot.getSlotIndex().getUint64());
	        }

	        return SCP.EnvelopeState.INVALID;
	    }

	    ValidationLevel validationRes = validateValues(statement);
	    if (validationRes != SCPDriver.ValidationLevel.kInvalidValue)
	    {
	        boolean processed = false;

	        if (mPhase != SCPPhase.SCP_PHASE_EXTERNALIZE)
	        {
	            if (validationRes == SCPDriver.ValidationLevel.kMaybeValidValue)
	            {
	                mSlot.setFullyValidated(false);
	            }

	            recordEnvelope(envelope);
	            processed = true;
	            advanceSlot(statement);
	            res = SCP.EnvelopeState.VALID;
	        }

	        if (!processed)
	        {
	            // note: this handles also our own messages
	            // in particular our final EXTERNALIZE message
	            if (mPhase == SCPPhase.SCP_PHASE_EXTERNALIZE &&
	                mCommit.getValue().equals(getWorkingBallot(statement).getValue()))
	            {
	                recordEnvelope(envelope);
	                res = SCP.EnvelopeState.VALID;
	            }
	            else
	            {
	                if (self)
	                {
	    	            log.error("SCP externalize statement with invalid value from self, skipping e: {}", mSlot.getSCP().envToStr(envelope));
	                }

	                res = SCP.EnvelopeState.INVALID;
	            }
	        }
	    }
	    else
	    {
	        // If the value is not valid, we just ignore it.
	        if (self)
	        {
	            log.error("SCP invalid value from self, skipping e: {}", mSlot.getSCP().envToStr(envelope));
	        }
	        else
	        {
	            log.trace("SCP invalid value i: {}", mSlot.getSlotIndex().getUint64());
	        }

	        res = SCP.EnvelopeState.INVALID;
	    }
	    return res;
	}
	
	public void ballotProtocolTimerExpired()
	{
	    // don't abandon the ballot until we have heard from a slice
	    if (Boolean.TRUE.equals(mHeardFromQuorum))
	    {
	        abandonBallot(Uint32.ZERO);
	    }
	    else
	    {
	        log.debug("SCP Waiting to hear from a slice.");
	        startBallotProtocolTimer();
	    }
	}

	public boolean abandonBallot(Uint32 n)
	{
	    log.debug("SCP BallotProtocol::abandonBallot");
	    boolean res = false;
	    Value v = mSlot.getLatestCompositeCandidate();
	    if (v.isEmpty())
	    {
	        if (mCurrentBallot != null)
	        {
	            v = mCurrentBallot.getValue();
	        }
	    }
	    if (! v.isEmpty())
	    {
	        if (n.eqZero())
	        {
	            res = bumpState(v, true);
	        }
	        else
	        {
	            res = bumpState(v, n);
	        }
	    }
	    return res;
	}

	public boolean bumpState(Value value, boolean force)
	{
	    if (!force && (mCurrentBallot != null))
	    {
	        return false;
	    }

	    //SCPBallot newb;//?????????? C++ unused ?? bug ??

	    Uint32 n = mCurrentBallot != null ? mCurrentBallot.getCounter().plus(1) : Uint32.ONE;

	    return bumpState(value, n);
	}

	public boolean bumpState(Value value, Uint32 n)
	{
	    if (mPhase != SCPPhase.SCP_PHASE_PREPARE && mPhase != SCPPhase.SCP_PHASE_CONFIRM)
	    {
	        return false;
	    }

	    SCPBallot newb;

	    if (mHighBallot != null)
	    {
	        // can only bump the counter if we committed to something already
	    	newb = new SCPBallot(n, mHighBallot.getValue());
	    }
	    else
	    {
	    	newb = new SCPBallot(n, value);
	    }

	    log.debug("SCP BallotProtocol::bumpState  i: {} v: {}", mSlot.getSlotIndex().getUint64(), mSlot.getSCP().ballotToStr(newb));

	    boolean updated = updateCurrentValue(newb);

	    if (updated)
	    {
	        mSlot.getSCPDriver().startedBallotProtocol(mSlot.getSlotIndex(), newb);
	        emitCurrentStateStatement();
	    }

	    return updated;
	}


	////////////////////////////////////////////////////////////////
	boolean isNewerStatement(NodeID nodeID, SCPStatement st)
	{
		SCPEnvelope oldp = mLatestEnvelopes.get(nodeID);
	    boolean res = false;

	    if (oldp == null)
	    {
	        res = true;
	    }
	    else
	    {
	        res = isNewerStatement(oldp.getStatement(), st);
	    }
	    return res;
	}

	boolean isNewerStatement(SCPStatement oldst,
	                                 SCPStatement st)
	{
	    boolean res = false;

	    // total ordering described in SCP paper.
	    SCPStatementType stType = st.getPledges().getDiscriminant();
	    SCPStatementType oldstType = oldst.getPledges().getDiscriminant();

	    // statement type (PREPARE < CONFIRM < EXTERNALIZE)
	    if (oldstType != stType)
	    {
	        res = (oldstType.getValue() < stType.getValue());
	    }
	    else
	    {
	        // can't have duplicate EXTERNALIZE statements
	        if (stType == SCPStatementType.SCP_ST_EXTERNALIZE)
	        {
	            res = false;
	        }
	        else if (stType == SCPStatementType.SCP_ST_CONFIRM)
	        {
	            // sorted by (b, p, p', h) (p' = 0 implicitely)
	            SCPStatementConfirm oldC = oldst.getPledges().getConfirm();
	            SCPStatementConfirm c = st.getPledges().getConfirm();
	            int compBallot = compareBallots(oldC.getBallot(), c.getBallot());
	            if (compBallot < 0)
	            {
	                res = true;
	            }
	            else if (compBallot == 0)
	            {
	                if (oldC.getNPrepared().eq(c.getNPrepared()))
	                {
	                    res = (oldC.getNH().lt(c.getNH()));
	                }
	                else
	                {
	                    res = oldC.getNPrepared().lt(c.getNPrepared());
	                }
	            }
	        }
	        else
	        {
	            // Lexicographical order between PREPARE statements:
	            // (b, p, p', h)
	            SCPStatementPrepare oldPrep = oldst.getPledges().getPrepare();
	            SCPStatementPrepare prep = st.getPledges().getPrepare();

	            int compBallot = compareBallots(oldPrep.getBallot(), prep.getBallot());
	            if (compBallot < 0)
	            {
	                res = true;
	            }
	            else if (compBallot == 0)
	            {
	                compBallot = compareBallots(oldPrep.getPrepared(), prep.getPrepared());
	                if (compBallot < 0)
	                {
	                    res = true;
	                }
	                else if (compBallot == 0)
	                {
	                    compBallot = compareBallots(oldPrep.getPreparedPrime(),
	                                                prep.getPreparedPrime());
	                    if (compBallot < 0)
	                    {
	                        res = true;
	                    }
	                    else if (compBallot == 0)
	                    {
	                        res = oldPrep.getNH().lt(prep.getNH());
	                    }
	                }
	            }
	        }
	    }

	    return res;
	}

	void recordEnvelope(SCPEnvelope env)
	{
	SCPStatement st = env.getStatement();
    mLatestEnvelopes.put(st.getNodeID(), env);
	    mSlot.recordStatement(env.getStatement());
	}
	
	boolean isStatementSane(SCPStatement st, boolean self)
	{
	    boolean res = true;

	    switch (st.getPledges().getDiscriminant())
	    {
	    case SCP_ST_PREPARE:
	    {
	    	SCPStatementPrepare p = Assert.assertNotNull(st.getPledges().getPrepare());
	        // self is allowed to have b = 0 (as long as it never gets emitted)
	        boolean isOK = self || p.getBallot().getCounter().gt(0);

	        isOK = isOK &&
	               ((p.getPreparedPrime() == null || p.getPrepared() == null) ||
	                (areBallotsLessAndIncompatible(p.getPreparedPrime(), p.getPrepared())));

	        isOK =
	            isOK && 
	            (p.getNH().eqZero() 
	            || 
	            (p.getPrepared() != null && p.getNH().lte(p.getPrepared().getCounter())));

	        // c != 0 -> c <= h <= b
	        isOK = isOK && 
	        		(p.getNC().eqZero() 
	        		|| 
	        		(p.getNH().ne(0) 
	        			&& p.getBallot().getCounter().gte(p.getNH()) 
	        			&& p.getNH().gte(p.getNC())));

	        if (!isOK)
	        {
	            log.debug("SCP Malformed PREPARE message");
	            res = false;
	        }
	    }
	    break;
	    case SCP_ST_CONFIRM:
	    {
	        SCPStatementConfirm c = st.getPledges().getConfirm();
	        // c <= h <= b
	        res = c.getBallot().getCounter().gt(0);
	        res = res && (c.getNH().lte(c.getBallot().getCounter()));
	        res = res && (c.getNCommit().lte(c.getNH()));
	        if (!res)
	        {
	            log.debug("SCP Malformed CONFIRM message");
	        }
	    }
	    break;
	    case SCP_ST_EXTERNALIZE:
	    {
	        SCPStatementExternalize e = st.getPledges().getExternalize();

	        res = e.getCommit().getCounter().gt(0);
	        res = res && e.getNH().gte(e.getCommit().getCounter());

	        if (!res)
	        {
	            log.debug("SCP Malformed EXTERNALIZE message");
	        }
	    }
	    break;
	    default:
	        Assert.abort();
	    }

	    return res;
	}



	// updates the local state based to the specificed ballot
	// (that could be a prepared ballot) enforcing invariants
	boolean updateCurrentValue(SCPBallot ballot)
	{
	    if (mPhase != SCPPhase. SCP_PHASE_PREPARE && mPhase != SCPPhase.SCP_PHASE_CONFIRM)
	    {
	        return false;
	    }

	    boolean updated = false;
	    if (mCurrentBallot == null)
	    {
	        bumpToBallot(ballot, true);
	        updated = true;
	    }
	    else
	    {
	        Assert.assertTrue(compareBallots(mCurrentBallot, ballot) <= 0);

	        if (mCommit != null && !areBallotsCompatible(mCommit, ballot))
	        {
	            return false;
	        }

	        int comp = compareBallots(mCurrentBallot, ballot);
	        if (comp < 0)
	        {
	            bumpToBallot(ballot, true);
	            updated = true;
	        }
	        else if (comp > 0)
	        {
	            // this code probably changes with the final version
	            // of the conciliator

	            // this case may happen if the other nodes are not
	            // following the protocol (and we end up with a smaller value)
	            // not sure what is the best way to deal
	            // with this situation
	            log.error("SCP BallotProtocol::updateCurrentValue attempt to bump to a smaller value");
	            // can't just bump to the value as we may already have
	            // statements at counter+1
	            return false;
	        }
	    }

	    if (updated)
	    {
	        log.trace("SCP BallotProtocol::updateCurrentValue updated");
	    }

	    checkInvariants();

	    return updated;
	}
	
	void bumpToBallot(SCPBallot ballot, boolean check)
	{
	    log.debug("SCP BallotProtocol::bumpToBallot i: {} b: {}",mSlot.getSlotIndex().getUint64(), mSlot.getSCP().ballotToStr(ballot));

	    // `bumpToBallot` should be never called once we committed.
	    Assert.assertTrue(mPhase != SCPPhase.SCP_PHASE_EXTERNALIZE);

	    if (check)
	    {
	        // We should move mCurrentBallot monotonically only
	    	Assert.assertTrue(mCurrentBallot == null ||
	                  compareBallots(ballot, mCurrentBallot) >= 0);
	    }

	    boolean gotBumped = mCurrentBallot == null || !(mCurrentBallot.equals(ballot));

	    mCurrentBallot = ballot;//??? make_unique<SCPBallot>(ballot);

	    mHeardFromQuorum = false;

	    if (gotBumped) {
	        startBallotProtocolTimer();
	    }
	}

	void startBallotProtocolTimer()
	{
		Duration timeout = mSlot.getSCPDriver().computeTimeout(mCurrentBallot.getCounter());
//
//	    std::shared_ptr<Slot> slot = mSlot.shared_from_this();
	    mSlot.getSCPDriver()
	    .setupTimer(
	        mSlot.getSlotIndex(), Slot.timerIDs.BALLOT_PROTOCOL_TIMER, timeout,
	        () -> {
	        	mSlot.getBallotProtocol().ballotProtocolTimerExpired();
	        });
	}


	SCPStatement createStatement(SCPStatementType type)
	{
	    SCPStatement statement = new SCPStatement();

	    checkInvariants();
	    SCPStatementPledges pledges = new SCPStatementPledges();
	    pledges.setDiscriminant(type);
	    statement.setPledges(pledges);
	    switch (type)
	    {
	    case SCP_ST_PREPARE:
	    {
	        SCPStatementPrepare p = new SCPStatementPrepare();
	        p.setQuorumSetHash(getLocalNode().getQuorumSetHash());
	        if (mCurrentBallot != null)
	        {
	            p.setBallot(mCurrentBallot);
	        }
	        if (mCommit != null)
	        {
	            p.setNC(mCommit.getCounter());
	        }
	        if (mPrepared != null)
	        {
	            p.setPrepared(mPrepared);//?? p.getPrepared().activate() = mPrepared;
	        }
	        if (mPreparedPrime != null)
	        {
	            p.setPreparedPrime(mPreparedPrime);
	        }
	        if (mHighBallot != null)
	        {
	            p.setNH(mHighBallot.getCounter());
	        }
	        pledges.setPrepare(p);
	    }
	    break;
	    case SCP_ST_CONFIRM:
	    {
	        SCPStatementConfirm c = new SCPStatementConfirm();
	        c.setQuorumSetHash(getLocalNode().getQuorumSetHash());
	        Assert.assertTrue(areBallotsLessAndCompatible(mCommit, mHighBallot));
	        c.setBallot(mCurrentBallot);
	        c.setNPrepared(mPrepared.getCounter());
	        c.setNCommit(mCommit.getCounter());
	        c.setNH(mHighBallot.getCounter());
	        pledges.setConfirm(c);
	    }
	    break;
	    case SCP_ST_EXTERNALIZE:
	    {
	    	Assert.assertTrue(areBallotsLessAndCompatible(mCommit, mHighBallot));
	       SCPStatementExternalize e = new SCPStatementExternalize();
	        e.setCommit(mCommit);
	        e.setNH(mHighBallot.getCounter());
	        e.setCommitQuorumSetHash(getLocalNode().getQuorumSetHash());
	        pledges.setExternalize(e);
	    }
	    break;
	    default:
	    	Assert.abort();
	    }

	    return statement;
	}

	void emitCurrentStateStatement()
	{
	    SCPStatementType t;

	    switch (mPhase)
	    {
	    case SCP_PHASE_PREPARE:
	        t = SCPStatementType.SCP_ST_PREPARE;
	        break;
	    case SCP_PHASE_CONFIRM:
	        t = SCPStatementType.SCP_ST_CONFIRM;
	        break;
	    case SCP_PHASE_EXTERNALIZE:
	        t = SCPStatementType.SCP_ST_EXTERNALIZE;
	        break;
	    default:
	    	Assert.abort();
	    	throw new IllegalStateException();
	    }

	    SCPStatement statement = createStatement(t);
	    SCPEnvelope envelope = mSlot.createEnvelope(statement);

	    boolean canEmit = (mCurrentBallot != null);

	    // if we generate the same envelope, don't process it again
	    // this can occur when updating h in PREPARE phase
	    // as statements only keep track of h.n (but h.x could be different)
	    SCPEnvelope lastEnv = mLatestEnvelopes.get(mSlot.getSCP().getLocalNodeID());

	    if (lastEnv == null || !(lastEnv.equals(envelope)))
	    {
	        if (mSlot.processEnvelope(envelope, true) == SCP.EnvelopeState.VALID)
	        {
	            if (canEmit &&
	                (mLastEnvelope == null|| isNewerStatement(mLastEnvelope.getStatement(),
	                                                    envelope.getStatement())))
	            {
	                mLastEnvelope = envelope;
	                // this will no-op if invoked from advanceSlot
	                // as advanceSlot consolidates all messages sent
	                sendLatestEnvelope();
	            }
	        }
	        else
	        {
	            // there is a bug in the application if it queued up
	            // a statement for itself that it considers invalid
	            throw new IllegalStateException("moved to a bad state (ballot protocol)");
	        }
	    }
	}

	void checkInvariants()
	{
	    if (mCurrentBallot != null)
	    {
	    	Assert.assertTrue(mCurrentBallot.getCounter().ne(0));
	    }
	    if (mPrepared != null && mPreparedPrime != null)
	    {
	    	Assert.assertTrue(areBallotsLessAndIncompatible(mPreparedPrime, mPrepared));
	    }
	    if (mCommit != null)
	    {
	    	Assert.assertTrue(mCurrentBallot != null);
	    	Assert.assertTrue(areBallotsLessAndCompatible(mCommit, mHighBallot));
	    	Assert.assertTrue(areBallotsLessAndCompatible(mHighBallot, mCurrentBallot));
	    }

	    switch (mPhase)
	    {
	    case SCP_PHASE_PREPARE:
	        break;
	    case SCP_PHASE_CONFIRM:
	    	Assert.assertTrue(mCommit != null);
	        break;
	    case SCP_PHASE_EXTERNALIZE:
	    	Assert.assertTrue(mCommit != null);
	    	Assert.assertTrue(mHighBallot != null);
	        break;
	    default:
	    	Assert.abort();
	    }
	}

	LinkedHashSet<SCPBallot> getPrepareCandidates(SCPStatement hint)
	{
		LinkedHashSet<SCPBallot> hintBallots = new LinkedHashSet<>();//??? Set ??

	    switch (hint.getPledges().getDiscriminant())
	    {
	    case SCP_ST_PREPARE:
	    {
	        SCPStatementPrepare prep = Assert.assertNotNull(hint.getPledges().getPrepare());
	        hintBallots.add(prep.getBallot());
	        if (prep.getPrepared() != null)//?? prep.prepared
	        {
	            hintBallots.add(prep.getPrepared());
	        }
	        if (prep.getPreparedPrime() != null)
	        {
	            hintBallots.add(prep.getPreparedPrime());
	        }
	    }
	    break;
	    case SCP_ST_CONFIRM:
	    {
	        SCPStatementConfirm con = Assert.assertNotNull(hint.getPledges().getConfirm());
	        hintBallots.add(new SCPBallot(con.getNPrepared(), con.getBallot().getValue()));
	        hintBallots.add(new SCPBallot(Uint32.UINT32_MAX, con.getBallot().getValue()));
	    }
	    break;
	    case SCP_ST_EXTERNALIZE:
	    {
	        SCPStatementExternalize ext = Assert.assertNotNull(hint.getPledges().getExternalize());
	        hintBallots.add(new SCPBallot(Uint32.UINT32_MAX, ext.getCommit().getValue()));
	    }
	    break;
	    default:
	    	Assert.abort();
	    };

	    List<SCPBallot> _l = new LinkedList<SCPBallot>(hintBallots);
	    Collections.reverse(_l);
	    Iterator<SCPBallot> hitBallotsRevItr = _l.iterator();
	    
	    if(! hitBallotsRevItr.hasNext()) {
	    	log.warn("CHECK hitBallotsRevItr EMPTY");
	    }
	    
	    LinkedHashSet<SCPBallot> candidates = new LinkedHashSet<>();
	    while (hitBallotsRevItr.hasNext())
	    {
	        SCPBallot topVote = hitBallotsRevItr.next();

	        Value val = topVote.getValue();

	        // find candidates that may have been prepared
	        for (SCPEnvelope e : mLatestEnvelopes.values())
	        {
	            SCPStatement st = e.getStatement();
	            switch (st.getPledges().getDiscriminant())
	            {
	            case SCP_ST_PREPARE:
	            {
	                SCPStatementPrepare prep = Assert.assertNotNull(st.getPledges().getPrepare());
	                if (areBallotsLessAndCompatible(prep.getBallot(), topVote))
	                {
	                    candidates.add(prep.getBallot());
	                }
	                if (prep.getPrepared() != null &&
	                    areBallotsLessAndCompatible(prep.getPrepared(), topVote))
	                {
	                    candidates.add(prep.getPrepared());
	                }
	                if (prep.getPreparedPrime() != null &&
	                    areBallotsLessAndCompatible(prep.getPreparedPrime(), topVote))
	                {
	                    candidates.add(prep.getPreparedPrime());
	                }
	            }
	            break;
	            case SCP_ST_CONFIRM:
	            {
	                SCPStatementConfirm con = Assert.assertNotNull(st.getPledges().getConfirm());
	                if (areBallotsCompatible(topVote, con.getBallot()))
	                {
	                    candidates.add(topVote);
	                    if (con.getNPrepared().lt(topVote.getCounter()))
	                    {
	                        candidates.add(new SCPBallot(con.getNPrepared(), val));
	                    }
	                }
	            }
	            break;
	            case SCP_ST_EXTERNALIZE:
	            {
	                SCPStatementExternalize ext = Assert.assertNotNull(st.getPledges().getExternalize());
	                if (areBallotsCompatible(topVote, ext.getCommit()))
	                {
	                    candidates.add(topVote);
	                }
	            }
	            break;
	            default:
	            	Assert.abort();
	            }
	        }
	    }

	    return candidates;
	}

	void updateCurrentIfNeeded()
	{
	    if (mCurrentBallot == null || compareBallots(mCurrentBallot, mHighBallot) < 0)
	    {
	        bumpToBallot(mHighBallot, true);
	    }
	}

	boolean attemptPreparedAccept(SCPStatement hint)
	{
	    if (mPhase != SCPPhase.SCP_PHASE_PREPARE && mPhase != SCPPhase.SCP_PHASE_CONFIRM)
	    {
	        return false;
	    }

	    LinkedHashSet<SCPBallot> candidates = getPrepareCandidates(hint);
	    // see if we can accept any of the candidates, starting with the highest
	    for (SCPBallot ballot : candidates)
	    {
	        if (mPhase == SCPPhase.SCP_PHASE_CONFIRM)
	        {
	            // only consider the ballot if it may help us increase
	            // p (note: at this point, p ~ c)
	            if (!areBallotsLessAndCompatible(mPrepared, ballot))
	            {
	                continue;
	            }
	            Assert.assertTrue(areBallotsCompatible(mCommit, ballot));
	        }

	        // if we already prepared this ballot, don't bother checking again

	        // if ballot <= p' ballot is neither a candidate for p nor p'
	        if (mPreparedPrime != null && compareBallots(ballot, mPreparedPrime) <= 0)
	        {
	            continue;
	        }

	        if (mPrepared != null)
	        {
	            // if ballot is already covered by p, skip
	            if (areBallotsLessAndCompatible(ballot, mPrepared))
	            {
	                continue;
	            }
	            // otherwise, there is a chance it increases p'
	        }

	        boolean accepted = federatedAccept(
	            // checks if any node is voting for this ballot
	            (SCPStatement st) -> {
	                boolean res;

	                switch (st.getPledges().getDiscriminant())
	                {
	                case SCP_ST_PREPARE:
	                {
	                	SCPStatementPrepare p = Assert.assertNotNull(st.getPledges().getPrepare());
	                    res = areBallotsLessAndCompatible(ballot, p.getBallot());
	                }
	                break;
	                case SCP_ST_CONFIRM:
	                {
	                	SCPStatementConfirm c = Assert.assertNotNull(st.getPledges().getConfirm());
	                    res = areBallotsCompatible(ballot, c.getBallot());
	                }
	                break;
	                case SCP_ST_EXTERNALIZE:
	                {
	                	SCPStatementExternalize e = Assert.assertNotNull(st.getPledges().getExternalize());
	                    res = areBallotsCompatible(ballot, e.getCommit());
	                }
	                break;
	                default:
	                	res = false;//javac
	                    Assert.abort();
	                }

	                return res;
	            }, (SCPStatement st) -> { return hasPreparedBallot(ballot, st); });
	        if (accepted)
	        {
	            return setPreparedAccept(ballot);
	        }
	    }

	    return false;
	}

	boolean setPreparedAccept(SCPBallot ballot)
	{
	        log.debug("SCP BallotProtocol::setPreparedAccept i: {$ b: {}",mSlot.getSlotIndex().getUint64(), mSlot.getSCP().ballotToStr(ballot));

	    // update our state
	    boolean didWork = setPrepared(ballot);

	    // check if we also need to clear 'c'
	    if (mCommit != null && mHighBallot != null)
	    {
	        if ((mPrepared != null &&
	             areBallotsLessAndIncompatible(mHighBallot, mPrepared)) ||
	            (mPreparedPrime != null &&
	             areBallotsLessAndIncompatible(mHighBallot, mPreparedPrime)))
	        {
	            Assert.assertTrue(mPhase == SCPPhase.SCP_PHASE_PREPARE);
	            
	            mCommit = null;//?? mCommit.reset(); ??
	            didWork = true;
	        }
	    }

	    if (didWork)
	    {
	        mSlot.getSCPDriver().acceptedBallotPrepared(mSlot.getSlotIndex(),
	                                                    ballot);
	        emitCurrentStateStatement();
	    }

	    return didWork;
	}

	boolean attemptPreparedConfirmed(SCPStatement hint)
	{
	    if (mPhase != SCPPhase.SCP_PHASE_PREPARE)
	    {
	        return false;
	    }

	    // check if we could accept this ballot as prepared
	    if (mPrepared == null)
	    {
	        return false;
	    }

	    LinkedHashSet<SCPBallot> candidates = getPrepareCandidates(hint);

	    // see if we can accept any of the candidates, starting with the highest

	    
	    SCPBallot newH = null;//not nice miki

	    
	    
	    boolean newHfound = false;
	    Iterator<SCPBallot> candItr = candidates.iterator();
	    while (candItr.hasNext())
	    {
	    	 SCPBallot ballot = candItr.next();
	        // only consider it if we can potentially raise h
	        if (mHighBallot != null && compareBallots(mHighBallot, ballot) >= 0)
	        {
	            break;
	        }

	        boolean ratified = federatedRatify((SCPStatement st) -> hasPreparedBallot(ballot, st));
	        if (ratified)
	        {
	            newH = ballot;
	            newHfound = true;
	            break;
	        }
	    }

	    boolean res = false;

	    if (newHfound)
	    {
	        SCPBallot newC = new SCPBallot(Uint32.ZERO, Value.NO_VALUE);///!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	        // now, look for newC (left as 0 if no update)
	        // step (3) from the paper
	        SCPBallot b = mCurrentBallot != null ? mCurrentBallot : new /*!!!!!!!!!!!!!!!!!!!!*/SCPBallot();
	        if (mCommit == null &&
	            (mPrepared == null || !areBallotsLessAndIncompatible(newH, mPrepared)) &&
	            (mPreparedPrime == null ||
	             !areBallotsLessAndIncompatible(newH, mPreparedPrime)))
	        {
	            // continue where we left off (cur is at newH at this point)
	        	while (candItr.hasNext())
	    	    {
	    	    	SCPBallot ballot = candItr.next();
	                if (compareBallots(ballot, b) < 0)
	                {
	                    break;
	                }
	                boolean ratified = federatedRatify((st) -> hasPreparedBallot(ballot, st));
	                if (ratified)
	                {
	                    newC = ballot;
	                }
	                else
	                {
	                    break;
	                }
	            }
	        }
	        res = setPreparedConfirmed(newC, newH);
	    }
	    return res;
	}

	boolean commitPredicate(SCPBallot ballot, UInt32Interval check,
	                                SCPStatement st)
	{
	    boolean res = false;
	    SCPStatementPledges pl = st.getPledges();
	    switch (pl.getDiscriminant())
	    {
	    case SCP_ST_PREPARE:
	        break;
	    case SCP_ST_CONFIRM:
	    {
	        SCPStatementConfirm c = Assert.assertNotNull(pl.getConfirm());
	        if (areBallotsCompatible(ballot, c.getBallot()))
	        {
	            res = c.getNCommit().lte(check.getLower()) 
	            	&& check.getUpper().lte(c.getNH());//TODO more elegant single interval method
	        }
	    }
	    break;
	    case SCP_ST_EXTERNALIZE:
	    {
	    	SCPStatementExternalize e = pl.getExternalize();
	        if (areBallotsCompatible(ballot, e.getCommit()))
	        {
	            res = e.getCommit().getCounter().lte(check.getLower());
	        }
	    }
	    break;
	    default:
	        Assert.abort();
	    }
	    return res;
	}

	boolean setPreparedConfirmed(SCPBallot newC,
	                                     SCPBallot newH)
	{
	        log.debug("SCP BallotProtocol::setPreparedConfirmed i: {} h: {}", mSlot.getSlotIndex().getUint64(),
	                           mSlot.getSCP().ballotToStr(newH));

	    boolean didWork = false;

	    if (mHighBallot == null || compareBallots(newH, mHighBallot) > 0)
	    {
	        didWork = true;
	        mHighBallot = newH;
	    }

	    if (newC.getCounter().ne(0))
	    {
	    	Assert.assertTrue(mCommit == null);
	        mCommit = newC;
	        didWork = true;
	    }

	    if (didWork)
	    {
	        updateCurrentIfNeeded();

	        mSlot.getSCPDriver().confirmedBallotPrepared(mSlot.getSlotIndex(),
	                                                     newH);
	        emitCurrentStateStatement();
	    }

	    return didWork;
	}
	
	UInt32Interval findExtendedInterval(/*UInt32Interval candidate,*/
	                                     Collection<Uint32> boundaries,
	                                     Predicate<UInt32Interval> pred)
	{
		UInt32Interval candidate = new UInt32Interval(Uint32.ZERO, Uint32.ZERO);
	    // iterate through interesting boundaries, starting from the top
	    for (Uint32 b : boundaries)
	    {

	    	UInt32Interval cur;
	        if (candidate.getLower().eqZero())
	        {
	            // first, find the high bound
	            cur = new UInt32Interval(b, b);
	        }
	        else if (b.gt(candidate.getUpper())) // invalid
	        {
	            continue;
	        }
	        else
	        {
	        	cur = new UInt32Interval(b, candidate.getUpper());
//	            cur.setFirst(b);
//	            cur.setSecond(candidate.getUpper());
	        }

	        if (pred.test(cur))
	        {
	            candidate = cur;
	        }
	        else if (candidate.getLower().ne(0))
	        {
	            // could not extend further
	            break;
	        }
	    }
	    return candidate;
	}

	LinkedHashSet<Uint32> getCommitBoundariesFromStatements(SCPBallot ballot)
	{
		LinkedHashSet<Uint32> res = new LinkedHashSet<>();
	    for (SCPEnvelope env : mLatestEnvelopes.values())
	    {
	        SCPStatementPledges pl = env.getStatement().getPledges();
	        switch (pl.getDiscriminant())
	        {
	        case SCP_ST_PREPARE:
	        {
	            SCPStatementPrepare p = Assert.assertNotNull(pl.getPrepare());
	            if (areBallotsCompatible(ballot, p.getBallot()))
	            {
	                if (p.getNC() != null)
	                {
	                    res.add(p.getNC());
	                    res.add(p.getNH());
	                }
	            }
	        }
	        break;
	        case SCP_ST_CONFIRM:
	        {
	        	SCPStatementConfirm c = Assert.assertNotNull(pl.getConfirm());
	            if (areBallotsCompatible(ballot, c.getBallot()))
	            {
	                res.add(c.getNCommit());
	                res.add(c.getNH());
	            }
	        }
	        break;
	        case SCP_ST_EXTERNALIZE:
	        {
	        	SCPStatementExternalize e = Assert.assertNotNull(pl.getExternalize());
	            if (areBallotsCompatible(ballot, e.getCommit()))
	            {
	                res.add(e.getCommit().getCounter());
	                res.add(e.getNH());
	                res.add(Uint32.UINT32_MAX);
	            }
	        }
	        break;
	        default:
	            Assert.abort();
	        }
	    }
	    return res;
	}

	boolean attemptAcceptCommit(SCPStatement hint)
	{
	    if (mPhase != SCPPhase.SCP_PHASE_PREPARE && mPhase != SCPPhase.SCP_PHASE_CONFIRM)
	    {
	        return false;
	    }

	    // extracts value from hint
	    // note: ballot.counter is only used for logging purpose as we're looking at
	    // possible value to commit
	    SCPBallot ballot;
	    switch (hint.getPledges().getDiscriminant())
	    {
	    case SCP_ST_PREPARE:
	    {
	        SCPStatementPrepare prep = Assert.assertNotNull(hint.getPledges().getPrepare());
	        if (prep.getNC().ne(0))
	        {
	            ballot = new SCPBallot(prep.getNH(), prep.getBallot().getValue());
	        }
	        else
	        {
	            return false;
	        }
	    }
	    break;
	    case SCP_ST_CONFIRM:
	    {
	    	SCPStatementConfirm con = Assert.assertNotNull(hint.getPledges().getConfirm());
	        ballot = new SCPBallot(con.getNH(), con.getBallot().getValue());
	    }
	    break;
	    case SCP_ST_EXTERNALIZE:
	    {
	    	SCPStatementExternalize ext = Assert.assertNotNull(hint.getPledges().getExternalize());
	        ballot = new SCPBallot(ext.getNH(), ext.getCommit().getValue());
	        break;
	    }
	    default:
	    	ballot = null;//just for javac complaining about initialization
	    	Assert.abort();
	    };

	    if (mPhase == SCPPhase.SCP_PHASE_CONFIRM)
	    {
	        if (!areBallotsCompatible(ballot, mHighBallot))
	        {
	            return false;
	        }
	    }

	    Predicate<UInt32Interval> pred = (UInt32Interval cur) -> {
	        return federatedAccept(
	            (SCPStatement st) -> {
	                boolean res = false;
	                SCPStatementPledges pl = st.getPledges();
	                switch (pl.getDiscriminant())
	                {
	                case SCP_ST_PREPARE:
	                {
	                	SCPStatementPrepare p = Assert.assertNotNull(pl.getPrepare());
	                    if (areBallotsCompatible(ballot, p.getBallot()))
	                    {
	                        if (p.getNC().ne(0))
	                        {
	                            res = p.getNC().lte(cur.getLower()) && cur.getUpper().lte(p.getNH());
	                        }
	                    }
	                }
	                break;
	                case SCP_ST_CONFIRM:
	                {
	                	SCPStatementConfirm c = Assert.assertNotNull(pl.getConfirm());
	                    if (areBallotsCompatible(ballot, c.getBallot()))
	                    {
	                        res = c.getNCommit().lte(cur.getLower());
	                    }
	                }
	                break;
	                case SCP_ST_EXTERNALIZE:
	                {
	                	SCPStatementExternalize e =Assert.assertNotNull( pl.getExternalize());
	                    if (areBallotsCompatible(ballot, e.getCommit()))
	                    {
	                        res = e.getCommit().getCounter().lte(cur.getLower());
	                    }
	                }
	                break;
	                default:
	                	Assert.abort();
	                }
	                return res;
	            }
	            ,
	            (SCPStatement st) -> commitPredicate(ballot, cur, st));
	    };

	    // build the boundaries to scan
	    LinkedHashSet<Uint32> boundaries = getCommitBoundariesFromStatements(ballot);

	    if (boundaries.isEmpty())
	    {
	        return false;
	    }

	    // now, look for the high interval
	    UInt32Interval candidate = findExtendedInterval(/*candidate, */boundaries, pred);//TODO UInt32Interval passed by ref not nice

	    boolean res = false;

	    if (candidate.getLower().ne(0))
	    {
	        if (mPhase != SCPPhase.SCP_PHASE_CONFIRM ||
	            candidate.getUpper().gt(mHighBallot.getCounter()))
	        {
	            SCPBallot c = new SCPBallot(candidate.getLower(), ballot.getValue());
	            SCPBallot h = new SCPBallot(candidate.getUpper(), ballot.getValue());
	            res = setAcceptCommit(c, h);
	        }
	    }

	    return res;
	}

	boolean setAcceptCommit(SCPBallot c, SCPBallot h)
	{
	    log.debug("SCP BallotProtocol::setAcceptCommit i: {} nec c: {} new h: {}", mSlot.getSlotIndex().getUint64()
	                           , mSlot.getSCP().ballotToStr(c)
	                           , mSlot.getSCP().ballotToStr(h));

	    boolean didWork = false;

	    if (mHighBallot == null || mCommit == null || compareBallots(mHighBallot, h) != 0 ||
	        compareBallots(mCommit, c) != 0)
	    {
	        mCommit = c;
	        mHighBallot = h;

	        didWork = true;
	    }

	    if (mPhase == SCPPhase.SCP_PHASE_PREPARE)
	    {
	        mPhase = SCPPhase.SCP_PHASE_CONFIRM;
	        if (mCurrentBallot != null && !areBallotsLessAndCompatible(h, mCurrentBallot))
	        {
	            bumpToBallot(h, false);
	        }
	        mPreparedPrime = null;//.reset();

	        didWork = true;
	    }

	    if (didWork)
	    {
	        updateCurrentIfNeeded();

	        mSlot.getSCPDriver().acceptedCommit(mSlot.getSlotIndex(), h);
	        emitCurrentStateStatement();
	    }

	    return didWork;
	}

	boolean attemptBump()
	{
	    if (mPhase == SCPPhase.SCP_PHASE_PREPARE || mPhase == SCPPhase.SCP_PHASE_CONFIRM)
	    {
	        // find all counters
	        LinkedHashSet<Uint32> allCounters = new LinkedHashSet<>();
	        for (SCPEnvelope e : mLatestEnvelopes.values())
	        {
	            SCPStatement st = e.getStatement();
	            switch (st.getPledges().getDiscriminant())
	            {
	            case SCP_ST_PREPARE:
	            {
	                SCPStatementPrepare p = Assert.assertNotNull(st.getPledges().getPrepare());
	                allCounters.add(p.getBallot().getCounter());
	            }
	            break;
	            case SCP_ST_CONFIRM:
	            {
	                SCPStatementConfirm c = Assert.assertNotNull(st.getPledges().getConfirm());
	                allCounters.add(c.getBallot().getCounter());
	            }
	            break;
	            case SCP_ST_EXTERNALIZE:
	            {
	                allCounters.add(Uint32.UINT32_MAX);
	            }
	            break;
	            default:
	                Assert.abort();
	            };
	        }
	        Uint32 targetCounter = mCurrentBallot != null ? mCurrentBallot.getCounter() : Uint32.ZERO;

	        // uses 0 as a way to track if a v-blocking set is at a higher counter
	        // if so, we move to that smallest counter
	        allCounters.add(targetCounter);

	        // go through the counters, find the smallest not v-blocking
	        for (Uint32 n : allCounters)
	        {
	            if (n.lt(targetCounter))
	            {
	                break;
	            }

	            boolean vBlocking = getLocalNode().getQuorumSet().isVBlocking(
	                mLatestEnvelopes,
	                (SCPStatement st) -> {
	                    boolean res;
	                    SCPStatementPledges pl = st.getPledges();
	                    if (pl.getDiscriminant() == SCPStatementType.SCP_ST_PREPARE)
	                    {
	                        SCPStatementPrepare p = Assert.assertNotNull(pl.getPrepare());
	                        res = n.lt(p.getBallot().getCounter());
	                    }
	                    else
	                    {
	                        if (pl.getDiscriminant() == SCPStatementType.SCP_ST_CONFIRM)
	                        {
	                            res = n.lt(pl.getConfirm().getBallot().getCounter());
	                        }
	                        else
	                        {
	                            res = n.ne(Uint32.UINT32_MAX);
	                        }
	                    }
	                    return res;
	                });

	            if (n.eq(targetCounter))
	            {
	                // if current counter is not behind, don't do anything
	                if (!vBlocking)
	                {
	                    break;
	                }
	            }
	            else
	            {
	                if (!vBlocking)
	                {
	                    // move to n
	                    return abandonBallot(n);
	                }
	            }
	        }
	    }

	    return false;
	}

	boolean attemptConfirmCommit(SCPStatement hint)
	{
	    if (mPhase != SCPPhase.SCP_PHASE_CONFIRM)
	    {
	        return false;
	    }

	    if (mHighBallot == null || mCommit == null)
	    {
	        return false;
	    }

	    // extracts value from hint
	    // note: ballot.counter is only used for logging purpose
	    SCPBallot ballot;
	    switch (hint.getPledges().getDiscriminant())
	    {
	    case SCP_ST_PREPARE:
	    {
	        return false;
	    }
	    //break;
	    case SCP_ST_CONFIRM:
	    {
	        SCPStatementConfirm con = Assert.assertNotNull(hint.getPledges().getConfirm());
	        ballot = new SCPBallot(con.getNH(), con.getBallot().getValue());
	    }
	    break;
	    case SCP_ST_EXTERNALIZE:
	    {
	        SCPStatementExternalize ext = Assert.assertNotNull(hint.getPledges().getExternalize());
	        ballot = new SCPBallot(ext.getNH(), ext.getCommit().getValue());
	        break;
	    }
	    default:
	    	ballot = null;//javac
	        Assert.abort();
	    };

	    if (!areBallotsCompatible(ballot, mCommit))
	    {
	        return false;
	    }

	    LinkedHashSet<Uint32> boundaries = getCommitBoundariesFromStatements(ballot);

	    Predicate<UInt32Interval> pred = (UInt32Interval cur) -> {
	        return federatedRatify( (st) -> commitPredicate(ballot, cur, st));
	    };


	    UInt32Interval candidate = 
	    findExtendedInterval(/*candidate, */boundaries, pred);

	    boolean res = candidate.getLower().ne(0);
	    if (res)
	    {
	        SCPBallot c = new SCPBallot(candidate.getLower(), ballot.getValue());
	        SCPBallot h = new SCPBallot(candidate.getUpper(), ballot.getValue());
	        return setConfirmCommit(c, h);
	    }
	    return res;
	}

	boolean setConfirmCommit(SCPBallot c, SCPBallot h)
	{
	    log.debug("SCP BallotProtocol::setConfirmCommit i: {} new c: {} new h: {}"
	                           , mSlot.getSlotIndex().getUint64()
	                           , mSlot.getSCP().ballotToStr(c)
	                           , mSlot.getSCP().ballotToStr(h));

	    mCommit = c;
	    mHighBallot = h;
	    updateCurrentIfNeeded();

	    mPhase = SCPPhase.SCP_PHASE_EXTERNALIZE;

	    emitCurrentStateStatement();

	    mSlot.stopNomination();

	    mSlot.getSCPDriver().valueExternalized(mSlot.getSlotIndex(),
	                                           mCommit.getValue());

	    return true;
	}

	boolean hasPreparedBallot(SCPBallot ballot, SCPStatement st)
	{
	    boolean res;

	    switch (st.getPledges().getDiscriminant())
	    {
	    case SCP_ST_PREPARE:
	    {
	        SCPStatementPrepare p = Assert.assertNotNull(st.getPledges().getPrepare());
	        res =
	            (p.getPrepared() != null && areBallotsLessAndCompatible(ballot, p.getPrepared())) ||
	            (p.getPreparedPrime() != null &&
	             areBallotsLessAndCompatible(ballot, p.getPreparedPrime()));
	    }
	    break;
	    case SCP_ST_CONFIRM:
	    {
	    	SCPStatementConfirm c = st.getPledges().getConfirm();
	        SCPBallot prepared = new SCPBallot(c.getNPrepared(), c.getBallot().getValue());
	        res = areBallotsLessAndCompatible(ballot, prepared);
	    }
	    break;
	    case SCP_ST_EXTERNALIZE:
	    {
	    	SCPStatementExternalize e = Assert.assertNotNull(st.getPledges().getExternalize());
	        res = areBallotsCompatible(ballot, e.getCommit());
	    }
	    break;
	    default:
	        res = false;
	        Assert.abort();
	    }

	    return res;
	}

	Hash getCompanionQuorumSetHashFromStatement(SCPStatement st)
	{
	    Hash h;
	    switch (st.getPledges().getDiscriminant())
	    {
	    case SCP_ST_PREPARE:
	        h = st.getPledges().getPrepare().getQuorumSetHash();
	        break;
	    case SCP_ST_CONFIRM:
	        h = st.getPledges().getConfirm().getQuorumSetHash();
	        break;
	    case SCP_ST_EXTERNALIZE:
	        h = st.getPledges().getExternalize().getCommitQuorumSetHash();
	        break;
	    default:
	    	h = null;//javac
	    	Assert.abort();
	    }
	    return h;
	}

	static SCPBallot getWorkingBallot(SCPStatement st)
	{
	    SCPBallot res;
	    switch (st.getPledges().getDiscriminant())
	    {
	    case SCP_ST_PREPARE:
	        res = st.getPledges().getPrepare().getBallot();
	        break;
	    case SCP_ST_CONFIRM:
	    {
	        SCPStatementConfirm con = st.getPledges().getConfirm();
	        res = new SCPBallot(con.getNCommit(), con.getBallot().getValue());
	    }
	    break;
	    case SCP_ST_EXTERNALIZE:
	        res = st.getPledges().getExternalize().getCommit();
	        break;
	    default:
	    	res = null;//javac
	    	Assert.abort();
	    }
	    return res;
	}

	boolean setPrepared(SCPBallot ballot)
	{
	    boolean didWork = false;

	    if (mPrepared != null)
	    {
	        int comp = compareBallots(mPrepared, ballot);
	        if (comp < 0)
	        {
	            if (!areBallotsCompatible(mPrepared, ballot))
	            {
	                mPreparedPrime = mPrepared;
	            }
	            mPrepared = ballot;
	            didWork = true;
	        }
	        else if (comp > 0)
	        {
	            // check if we should update only p'
	            if (mPreparedPrime == null || compareBallots(mPreparedPrime, ballot) < 0)
	            {
	                mPreparedPrime = ballot;
	                didWork = true;
	            }
	        }
	    }
	    else
	    {
	        mPrepared = ballot;
	        didWork = true;
	    }
	    return didWork;
	}

	////PRIVATE
private int compareBallots(@Nullable SCPBallot b1, @Nullable SCPBallot b2)
{
    int res;
    if (b1 != null && b2 != null)
    {
        res = compareNonNullBallots(b1, b2);
    }
    else if (b1 != null)
    {
        res = 1;
    }
    else if (b2 != null)
    {
        res = -1;
    }
    else
    {
        res = 0;
    }
    return res;
}

private int compareNonNullBallots(SCPBallot b1, SCPBallot b2)
{
    if (b1.getCounter().lt(b2.getCounter()))
    {
        return -1;
    }
    else if (b2.getCounter().lt(b1.getCounter()))
    {
        return 1;
    }
    // ballots are also strictly ordered by value
    if (b1.getValue().lt(b2.getValue()))
    {
        return -1;
    }
    else if (b2.getValue().lt(b1.getValue()))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

private boolean areBallotsCompatible(SCPBallot b1, SCPBallot b2)
{
    return b1.getValue().eq(b2.getValue());
}

private boolean areBallotsLessAndIncompatible(SCPBallot b1, SCPBallot b2)
{
    return (compareBallots(b1, b2) <= 0) && !areBallotsCompatible(b1, b2);
}

boolean areBallotsLessAndCompatible(SCPBallot b1, SCPBallot b2)
{
    return (compareBallots(b1, b2) <= 0) && areBallotsCompatible(b1, b2);
}

void setStateFromEnvelope(SCPEnvelope e)
{
    if (mCurrentBallot != null)
    {
        throw new RuntimeException(
            "Cannot set state after starting ballot protocol");
    }

    recordEnvelope(e);

    mLastEnvelope = e;
    mLastEnvelopeEmit = mLastEnvelope;

    SCPStatementPledges pl = e.getStatement().getPledges();

    switch (pl.getDiscriminant())
    {
    case SCP_ST_PREPARE:
    {
        SCPStatementPrepare prep = pl.getPrepare();
        SCPBallot b = prep.getBallot();
        bumpToBallot(b, true);
        if (prep.getPrepared() != null)
        {
            mPrepared = prep.getPrepared();
        }
        if (prep.getPreparedPrime() != null)
        {
            mPreparedPrime = prep.getPreparedPrime();
        }
        if (prep.getNH() != null)
        {
            mHighBallot = new SCPBallot(prep.getNH(), b.getValue());
        }
        if (prep.getNC() != null)
        {
            mCommit = new SCPBallot(prep.getNC(), b.getValue());
        }
        mPhase = SCPPhase.SCP_PHASE_PREPARE;
    }
    break;
    case SCP_ST_CONFIRM:
    {
        SCPStatementConfirm c = pl.getConfirm();
        Value v = c.getBallot().getValue();
        bumpToBallot(c.getBallot(), true);
        mPrepared = new SCPBallot(c.getNPrepared(), v);
        mHighBallot = new SCPBallot(c.getNH(), v);
        mCommit = new SCPBallot(c.getNCommit(), v);
        mPhase = SCPPhase.SCP_PHASE_CONFIRM;
    }
    break;
    case SCP_ST_EXTERNALIZE:
    {
    	SCPStatementExternalize ext = pl.getExternalize();
        Value v = ext.getCommit().getValue();
        bumpToBallot(new SCPBallot(Uint32.UINT32_MAX, v), true);
        mPrepared = new SCPBallot(Uint32.UINT32_MAX, v);
        mHighBallot = new SCPBallot(ext.getNH(), v);
        mCommit = ext.getCommit();
        mPhase = SCPPhase.SCP_PHASE_EXTERNALIZE;
    }
    break;
    default:
        Assert.abort();
    }
}

List<SCPEnvelope> getCurrentState() //const
{
    List<SCPEnvelope> res = new ArrayList<>(mLatestEnvelopes.size());
    for (Entry<NodeID,SCPEnvelope> n : mLatestEnvelopes.entrySet())
    {
        // only return messages for self if the slot is fully validated
        if (!(n.getKey().eq(mSlot.getSCP().getLocalNodeID()  )   ) ||
            mSlot.isFullyValidated())
        {
            res.add(n.getValue());
        }
    }
    return res;
}

List<SCPEnvelope> getExternalizingState() //const
{
    if (mPhase == SCPPhase.SCP_PHASE_EXTERNALIZE)
    {
        List<SCPEnvelope> res = new ArrayList<>(mLatestEnvelopes.size());
        for (Entry<NodeID,SCPEnvelope> n : mLatestEnvelopes.entrySet())
        {
            if (!(n.getKey().eq(mSlot.getSCP().getLocalNodeID()  )   ))
            {
                // good approximation: statements with the value that
                // externalized
                // we could filter more using mConfirmedPrepared as well
                if (areBallotsCompatible(getWorkingBallot(n.getValue().getStatement()),
                                         mCommit))
                {
                    res.add(n.getValue());
                }
            }
            else if (mSlot.isFullyValidated())
            {
                // only return messages for self if the slot is fully validated
                res.add(n.getValue());
            }
        }
        return res;
    } else {
    	return Collections.emptyList();
    }
}

void advanceSlot(SCPStatement hint)
{
    mCurrentMessageLevel++;
    log.debug("SCP BallotProtocol::advanceSlot {} {}",
        mCurrentMessageLevel, getLocalState());

    if (mCurrentMessageLevel >= MAX_ADVANCE_SLOT_RECURSION)
    {
        throw new RuntimeException(
            "maximum number of transitions reached in advanceSlot");
    }

    // Check if we should call `ballotDidHearFromQuorum`
    // we do this here so that we have a chance to evaluate it between
    // transitions
    // when a single message causes several
    if (! Boolean.TRUE.equals(mHeardFromQuorum) && mCurrentBallot != null)
    {
        if (getLocalNode().getQuorumSet().isQuorum(
                
                mLatestEnvelopes,
                
                (SCPStatement st) -> mSlot.getQuorumSetFromStatement(st),
                
                (SCPStatement st) -> {
                    boolean res;
                    if (st.getPledges().getDiscriminant() == SCPStatementType.SCP_ST_PREPARE)
                    {
                        res = mCurrentBallot.getCounter().lte( 
                              st.getPledges().getPrepare().getBallot().getCounter());
                    }
                    else
                    {
                        res = true;
                    }
                    return res;
                }
        		))
        {
            mHeardFromQuorum = true;
            mSlot.getSCPDriver().ballotDidHearFromQuorum(mSlot.getSlotIndex(),
                                                         mCurrentBallot);
        }
    }

    // attempt* methods will queue up messages, causing advanceSlot to be
    // called recursively

    // done in order so that we follow the steps from the white paper in
    // order
    // allowing the state to be updated properly

    boolean didWork = false;

    didWork = attemptPreparedAccept(hint) || didWork;

    didWork = attemptPreparedConfirmed(hint) || didWork;

    didWork = attemptAcceptCommit(hint) || didWork;

    didWork = attemptConfirmCommit(hint) || didWork;

    // only bump after we're done with everything else
    if (mCurrentMessageLevel == 1)
    {
        boolean didBump = false;
        do
        {
            // attemptBump may invoke advanceSlot recursively
            didBump = attemptBump();
            didWork = didBump || didWork;
        } while (didBump);
    }

    log.debug("SCP BallotProtocol::advanceSlot {} - exiting {}",
                           mCurrentMessageLevel, getLocalState());

    --mCurrentMessageLevel;

    if (didWork)
    {
        sendLatestEnvelope();
    }
}

SCPDriver.ValidationLevel validateValues(SCPStatement st)
{
    LinkedHashSet<Value> values = new LinkedHashSet<>();
    switch (st.getPledges().getDiscriminant())
    {
    case SCP_ST_PREPARE:
    {
        SCPStatementPrepare prep = st.getPledges().getPrepare();
        SCPBallot b = prep.getBallot();
        if (b.getCounter().ne(0))
        {
            values.add(prep.getBallot().getValue());
        }
        if (prep.getPrepared() != null)
        {
            values.add(prep.getPrepared().getValue());
        }
    }
    break;
    case SCP_ST_CONFIRM:
        values.add(st.getPledges().getConfirm().getBallot().getValue());
        break;
    case SCP_ST_EXTERNALIZE:
        values.add(st.getPledges().getExternalize().getCommit().getValue());
        break;
    default:
        // This shouldn't happen
        return SCPDriver.ValidationLevel.kInvalidValue;
    }
    SCPDriver.ValidationLevel res = SCPDriver.ValidationLevel.kFullyValidatedValue;
    for (Value v : values)
    {
    	SCPDriver.ValidationLevel tr = mSlot.getSCPDriver().validateValue(mSlot.getSlotIndex(), v);
        if (tr != SCPDriver.ValidationLevel.kFullyValidatedValue)
        {
            if (tr == SCPDriver.ValidationLevel.kInvalidValue)
            {
                res = SCPDriver.ValidationLevel.kInvalidValue;
            }
            else
            {
                res = SCPDriver.ValidationLevel.kMaybeValidValue;
            }
        }
    }
    return res;
}

void sendLatestEnvelope()
{
    // emit current envelope if needed
    if (mCurrentMessageLevel == 0 && mLastEnvelope != null && mSlot.isFullyValidated())
    {
        if (mLastEnvelopeEmit == null || mLastEnvelope != mLastEnvelopeEmit)//TODO use .equals ???? 
        {
            mLastEnvelopeEmit = mLastEnvelope;
            mSlot.getSCPDriver().emitEnvelope(mLastEnvelopeEmit);
        }
    }
}



String getLocalState()// const
{

return "i: " + mSlot.getSlotIndex().getUint64() + " | " + mPhase.name()
+ " | b: " + mSlot.getSCP().ballotToStr(mCurrentBallot)
+ " | p: " + mSlot.getSCP().ballotToStr(mPrepared)
+ " | p': " + mSlot.getSCP().ballotToStr(mPreparedPrime)
+ " | h: " + mSlot.getSCP().ballotToStr(mHighBallot)
+ " | c: " + mSlot.getSCP().ballotToStr(mCommit)
+ " | M: " + mLatestEnvelopes.size();

}


LocalNode getLocalNode()
{
    return mSlot.getSCP().getLocalNode();
}

boolean federatedAccept(Predicate<SCPStatement> voted,
		Predicate<SCPStatement> accepted)
{
    return mSlot.federatedAccept(voted, accepted, mLatestEnvelopes);
}

boolean federatedRatify(Predicate<SCPStatement> voted)
{
    return mSlot.federatedRatify(voted, mLatestEnvelopes);
}

SCPEnvelope getLastMessageSend()
{
    return mLastEnvelopeEmit;
}

void dumpInfo(/*Json::Value&*/Object ret) //by ref info dumped into ret
{
	//TODO
//    Json::Value& state = ret["ballotProtocol"];
//    state["heard"] = mHeardFromQuorum;
//    state["ballot"] = mSlot.getSCP().ballotToStr(mCurrentBallot);
//    state["phase"] = phaseNames[mPhase];
//
//    state["state"] = getLocalState();
}

void dumpQuorumInfo(/*Json::Value&O*/Object ret, NodeID id, boolean summary)//by ref info dumped into ret
{
//TODO
}
}
