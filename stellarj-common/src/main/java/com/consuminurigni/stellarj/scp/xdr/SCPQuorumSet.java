// Automatically generated by xdrgen 
// DO NOT EDIT or your changes may be overwritten

package com.consuminurigni.stellarj.scp.xdr;


import java.io.IOException;
import java.math.BigInteger;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

import org.springframework.lang.Nullable;

import com.consuminurigni.stellarj.xdr.Encodable;
import com.consuminurigni.stellarj.xdr.NodeID;
import com.consuminurigni.stellarj.xdr.PublicKey;
import com.consuminurigni.stellarj.xdr.Uint32;
import com.consuminurigni.stellarj.xdr.Uint64;
import com.consuminurigni.stellarj.xdr.XdrDataInputStream;
import com.consuminurigni.stellarj.xdr.XdrDataOutputStream;
import com.consuminurigni.stellarj.xdr.XdrInteger;

// === xdr source ============================================================

//  struct SCPQuorumSet
//  {
//      uint32 threshold;
//      PublicKey validators<>;
//      SCPQuorumSet innerSets<>;
//  };

//  ===========================================================================
public class SCPQuorumSet implements Encodable {
  public SCPQuorumSet () {}
  private Uint32 threshold;
  public Uint32 getThreshold() {
    return this.threshold;
  }
  public void setThreshold(Uint32 value) {
    this.threshold = value;
  }
  private PublicKey[] validators;
  public PublicKey[] getValidators() {
    return this.validators;
  }
  public void setValidators(PublicKey[] value) {
    this.validators = value;
  }
  private SCPQuorumSet[] innerSets;
  public SCPQuorumSet[] getInnerSets() {
    return this.innerSets;
  }
  public void setInnerSets(SCPQuorumSet[] value) {
    this.innerSets = value;
  }
  public static void encode(XdrDataOutputStream stream, SCPQuorumSet encodedSCPQuorumSet) throws IOException{
    Uint32.encode(stream, encodedSCPQuorumSet.threshold);
    int validatorssize = encodedSCPQuorumSet.getValidators().length;
    stream.writeInt(validatorssize);
    for (int i = 0; i < validatorssize; i++) {
      PublicKey.encode(stream, encodedSCPQuorumSet.validators[i]);
    }
    int innerSetssize = encodedSCPQuorumSet.getInnerSets().length;
    stream.writeInt(innerSetssize);
    for (int i = 0; i < innerSetssize; i++) {
      SCPQuorumSet.encode(stream, encodedSCPQuorumSet.innerSets[i]);
    }
  }
  public static SCPQuorumSet decode(XdrDataInputStream stream) throws IOException {
    SCPQuorumSet decodedSCPQuorumSet = new SCPQuorumSet();
    decodedSCPQuorumSet.threshold = Uint32.decode(stream);
    int validatorssize = stream.readInt();
    decodedSCPQuorumSet.validators = new PublicKey[validatorssize];
    for (int i = 0; i < validatorssize; i++) {
      decodedSCPQuorumSet.validators[i] = PublicKey.decode(stream);
    }
    int innerSetssize = stream.readInt();
    decodedSCPQuorumSet.innerSets = new SCPQuorumSet[innerSetssize];
    for (int i = 0; i < innerSetssize; i++) {
      decodedSCPQuorumSet.innerSets[i] = SCPQuorumSet.decode(stream);
    }
    return decodedSCPQuorumSet;
  }
public void pushValidator(PublicKey publicKey) {
	// TODO Auto-generated method stub
	
}
public void removeSetAt(int j) {
	// TODO Auto-generated method stub
	
}
public int numValidators() {
	// TODO Auto-generated method stub
	return 0;
}
public int numInnerSets() {
	// TODO Auto-generated method stub
	return 0;
}
public SCPQuorumSet getInnerSetAt(int j) {
	// TODO Auto-generated method stub
	return null;
}
public void setStateFrom(SCPQuorumSet innerSetAt) {
	// TODO Auto-generated method stub
	
}
@Override
public byte[] encode() {
	// TODO Auto-generated method stub
	return null;
}






private void forAllNodesInternal(Consumer<NodeID> proc)
{
    for (PublicKey n : getValidators())
    {
        proc.accept(n.toNodeID());
    }
    for (SCPQuorumSet q : getInnerSets())
    {
        q.forAllNodesInternal(proc);
    }
}


// runs proc over all nodes contained in qset
public void forAllNodes(Consumer<NodeID> proc)
{
    java.util.Set<NodeID> done = new HashSet<>();
    forAllNodesInternal((NodeID n) -> {
        if (! done.contains(n))
        {
            proc.accept(n);
            done.add(n);
        }
    });
}

// if a validator is repeated multiple times its weight is only the
// weight of the first occurrence
public Uint64 getNodeWeight(NodeID nodeID)
{
    BigInteger n = getThreshold().asBigInteger();
    BigInteger d = BigInteger.valueOf(getInnerSets().length + getValidators().length);
//    Uint64 res = new Uint64();

    for (PublicKey qsetNode : getValidators())
    {
        if (qsetNode.eq(nodeID))
        {
            return XdrInteger.bigDivide64(XdrInteger.UINT64_MAX, n, d, XdrInteger.Rounding.ROUND_DOWN);
        }
    }

    for (SCPQuorumSet q : getInnerSets())
    {
    	Uint64 leafW = q.getNodeWeight(nodeID);
        if (leafW.neq(0))
        {
        	return XdrInteger.bigDivide64(leafW.toBigInteger(), n, d, XdrInteger.Rounding.ROUND_DOWN);
        }
    }
    return Uint64.ZERO;
}

private boolean isQuorumSliceInternal(NodeSet nodeSet)
{
    int thresholdLeft = getThreshold().intValue();
    for (PublicKey validator : getValidators())
    {
    	//TODO ugly contains() replace with set/list of elements implementing equals
    		if(nodeSet.contains(validator.toNodeID())) {
	            thresholdLeft--;
	            if (thresholdLeft <= 0)
	            {
	                return true;
	            }
    		}
    }

    for (SCPQuorumSet inner : getInnerSets())
    {
        if (inner.isQuorumSliceInternal(nodeSet))
        {
            thresholdLeft--;
            if (thresholdLeft <= 0)
            {
                return true;
            }
        }
    }
    return false;
}

private boolean isQuorumSlice(NodeSet nodeSet)
{
//TODO    log.trace("SCP LocalNode::isQuorumSlice nodeSet.size:{}", nodeSet.size());

    return isQuorumSliceInternal(nodeSet);
}

// called recursively
private boolean isVBlockingInternal(NodeSet nodeSet)
{
    // There is no v-blocking set for {\empty}
    if (getThreshold().eqZero())
    {
        return false;
    }

    int leftTillBlock =
        (int)((1 + getValidators().length + getInnerSets().length) -
              getThreshold().intValue());

    for (PublicKey validator : getValidators())
    {
    	if(nodeSet.contains(validator))
        {
            leftTillBlock--;
            if (leftTillBlock <= 0)
            {
                return true;
            }
        }
    }
    for (SCPQuorumSet inner : getInnerSets())
    {
        if (inner.isVBlockingInternal(nodeSet))
        {
            leftTillBlock--;
            if (leftTillBlock <= 0)
            {
                return true;
            }
        }
    }

    return false;
}

private boolean isVBlocking(NodeSet nodeSet)
{
//TODDO    log.trace("SCP LocalNode::isVBlocking nodeSet.size:{}", nodeSet.size());

    return isVBlockingInternal(nodeSet);
}

public boolean isVBlocking(Map<NodeID, SCPEnvelope> mLatestEnvelopes,
		Predicate<SCPStatement> filter) {
	NodeSet pNodes = new NodeSet();
    for (Entry<NodeID, SCPEnvelope> it : mLatestEnvelopes.entrySet())
    {
        if (filter.test(it.getValue().getStatement()))
        {
            pNodes.add(it.getKey());
        }
    }

    return isVBlocking(pNodes);
}

public boolean isQuorum(Map<NodeID, SCPEnvelope> mLatestEnvelopes, final Function<SCPStatement, SCPQuorumSet> qfun,
		Predicate<SCPStatement> filter) {
	NodeSet pNodes = new NodeSet();
    for (Entry<NodeID, SCPEnvelope> it : mLatestEnvelopes.entrySet())
    {
        if (filter.test(it.getValue().getStatement()))
        {
            pNodes.add(it.getKey());
        }
    }

    int count = 0;
    do
    {
    	
        count = pNodes.size();
        NodeSet fNodes = new NodeSet();
        //std::vector<NodeID> fNodes(pNodes.size());
        BiPredicate<NodeID, NodeSet> quorumFilter =(NodeID nodeID, NodeSet __pNodes__) -> {
        	SCPEnvelope scpEnvelope = mLatestEnvelopes.get(nodeID);
        	if(scpEnvelope == null) {
        		return false;//TODO needed ??
        	}
			SCPQuorumSet qSetPtr = qfun.apply(scpEnvelope.getStatement());
            if (qSetPtr != null)
            {
                return qSetPtr.isQuorumSlice(__pNodes__);
            }
            else
            {
                return false;
            }
        };
        for(NodeID nid : pNodes) {
        	if(quorumFilter.test(nid, pNodes)) {
        		fNodes.add(nid);
        	}
        }
        pNodes = fNodes;
    } while (count != pNodes.size());

    return isQuorumSlice(pNodes);
}


//std::vector<NodeID>
//LocalNode::findClosestVBlocking(
//    SCPQuorumSet const& qset, std::map<NodeID, SCPEnvelope> const& map,
//    std::function<bool(SCPStatement const&)> const& filter,
//    NodeID const* excluded)
//{
//    std::set<NodeID> s;
//    for (auto const& n : map)
//    {
//        if (filter(n.second.statement))
//        {
//            s.emplace(n.first);
//        }
//    }
//    return findClosestVBlocking(qset, s, excluded);
//}

private NodeSet findClosestVBlocking(NodeSet nodes, @Nullable NodeID excluded)
{
    int leftTillBlock =
        ((1 + getValidators().length + getInnerSets().length) - getThreshold().intValue());

    NodeSet res = new NodeSet();

    // first, compute how many top level items need to be blocked
    for (PublicKey validator : getValidators())
    {
        if (excluded == null || !(validator.eq(excluded)))
        {
            if (! nodes.contains(validator.toNodeID()))
            {
                leftTillBlock--;
                if (leftTillBlock == 0)
                {
                    // already blocked
                    return new NodeSet();
                }
            }
            else
            {
                // save this for later
                res.add(validator);
            }
        }
    }

//    struct orderBySize
//    {
//        bool
//        operator()(std::vector<NodeID> const& v1, std::vector<NodeID> const& v2)
//        {
//            return v1.size() < v2.size();
//        }
//    };

    List<NodeSet> resInternals = new LinkedList<>();

    for (SCPQuorumSet inner :getInnerSets())
    {
    	NodeSet v = inner.findClosestVBlocking(nodes, excluded);
        if (v.size() == 0)
        {
            leftTillBlock--;
            if (leftTillBlock == 0)
            {
                // already blocked
                return new NodeSet();
            }
        }
        else
        {
            resInternals.add(v);
        }
    }
    Collections.sort(resInternals, NodeSet.BY_SIZE_COMPARATOR);
    leftTillBlock -= res.size();

    // use subsets to get closer, using the smallest ones first
    Iterator<NodeSet> it = resInternals.iterator();
    while (leftTillBlock != 0 && it.hasNext())
    {
        res.addAll(it.next());
        leftTillBlock--;
    }
    return res;
}
public static SCPQuorumSet buildSingletonQSet(NodeID nodeID)
{
    SCPQuorumSet qSet = new SCPQuorumSet();
    qSet.setThreshold(Uint32.ofPositiveInt(1));
    qSet.setValidators(new PublicKey[] {nodeID.getNodeID()});
    return qSet;
}
public static SCPQuorumSet decode(byte[] qSetBytes) {
	// TODO Auto-generated method stub
	return null;
}

}
